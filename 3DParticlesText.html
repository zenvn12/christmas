<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<title>Particle Text – Sphere Only</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
html,body{
  margin:0;
  overflow:hidden;
  background:#0b0b0e;
  font-family:system-ui;
}

#ui{
  position:fixed;
  top:16px;
  left:16px;
  display:flex;
  gap:10px;
  padding:12px;
  background:rgba(20,20,30,.65);
  backdrop-filter:blur(10px);
  border-radius:14px;
  z-index:10;
}

input{
  background:#111;
  color:white;
  border:none;
  padding:8px 10px;
  border-radius:8px;
  outline:none;
}

input[type=color]{
  width:36px;
  height:36px;
  padding:0;
}
</style>
</head>

<body>
<div id="ui">
  <input id="textInput" maxlength="50" placeholder="Nhập chữ hoặc số">
  <input type="color" id="colorPicker" value="#5aa9ff">
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.158/build/three.min.js"></script>

<script>
/* ===== THREE ===== */
const scene = new THREE.Scene()
const camera = new THREE.PerspectiveCamera(60,innerWidth/innerHeight,0.1,1000)
camera.position.z = 150

const renderer = new THREE.WebGLRenderer({antialias:true})
renderer.setSize(innerWidth,innerHeight)
renderer.setPixelRatio(devicePixelRatio)
document.body.appendChild(renderer.domElement)

/* ===== LIGHT ===== */
scene.add(new THREE.AmbientLight(0xffffff,0.85))
const dir=new THREE.DirectionalLight(0xffffff,0.6)
dir.position.set(1,1,1)
scene.add(dir)

/* ===== PARTICLES ===== */
const COUNT = 3000
const sphereGeo = new THREE.SphereGeometry(0.9,10,10)

const material = new THREE.MeshStandardMaterial({
  color:0x5aa9ff,
  roughness:0.35,
  metalness:0.1
})

const mesh = new THREE.InstancedMesh(
  sphereGeo,
  material,
  COUNT
)
scene.add(mesh)

const dummy = new THREE.Object3D()

/* ===== TEXT → POINTS ===== */
function textToPoints(text){
  const len=text.length||1
  const fontSize=Math.max(60,240-len*4)

  const c=document.createElement("canvas")
  c.width=800; c.height=300
  const ctx=c.getContext("2d")

  ctx.clearRect(0,0,800,300)
  ctx.fillStyle="#fff"
  ctx.font=`bold ${fontSize}px Arial`
  ctx.textAlign="center"
  ctx.textBaseline="middle"
  ctx.fillText(text,400,150)

  const img=ctx.getImageData(0,0,800,300).data
  const pts=[]

  for(let y=0;y<300;y+=4){
    for(let x=0;x<800;x+=4){
      const i=(y*800+x)*4
      if(img[i]>200){
        pts.push(new THREE.Vector3(
          (x-400)*0.35,
          (150-y)*0.35,
          0
        ))
      }
    }
  }
  return pts
}

let targetPoints = []

/* ===== UI ===== */
textInput.oninput=e=>{
  const t=e.target.value.trim()
  targetPoints = t?textToPoints(t):[]
}

colorPicker.oninput=e=>{
  material.color.set(e.target.value)
}

/* ===== LOOP ===== */
function animate(){
  requestAnimationFrame(animate)

  for(let i=0;i<COUNT;i++){
    const p=targetPoints[i%targetPoints.length] || new THREE.Vector3()
    dummy.position.lerp(p,0.12)
    dummy.updateMatrix()
    mesh.setMatrixAt(i,dummy.matrix)
  }
  mesh.instanceMatrix.needsUpdate=true
  mesh.rotation.y+=0.0015

  renderer.render(scene,camera)
}
animate()

window.onresize=()=>{
  camera.aspect=innerWidth/innerHeight
  camera.updateProjectionMatrix()
  renderer.setSize(innerWidth,innerHeight)
}
</script>
</body>
</html>
