<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<title>Hiệu ứng 3D Chữ</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
html,body{
  margin:0;
  overflow:hidden;
  background:#0b0b0e;
  font-family:system-ui;
}

#ui{
  position:fixed;
  top:16px;
  left:16px;
  display:flex;
  gap:8px;
  padding:12px;
  background:rgba(20,20,30,.65);
  backdrop-filter:blur(10px);
  border-radius:14px;
  z-index:10;
}

input,select{
  background:#111;
  color:white;
  border:none;
  padding:8px 10px;
  border-radius:8px;
  outline:none;
}

input[type=color]{
  width:36px;
  height:36px;
  padding:0;
}
</style>
</head>

<body>
<div id="ui">
  <input id="textInput" maxlength="50" placeholder="Nhập chữ hoặc số">
  <select id="shapeSelect">
    <option value="square">⬜ Vuông</option>
    <option value="sphere">⚪ Cầu</option>
    <option value="star">⭐ Ngôi sao</option>
    <option value="heart">❤️ Trái tim</option>
  </select>
  <input type="color" id="colorPicker" value="#5aa9ff">
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.158/build/three.min.js"></script>

<script>
/* ===== THREE ===== */
const scene = new THREE.Scene()
const camera = new THREE.PerspectiveCamera(60,innerWidth/innerHeight,0.1,1000)
camera.position.z = 150

const renderer = new THREE.WebGLRenderer({antialias:true})
renderer.setSize(innerWidth,innerHeight)
renderer.setPixelRatio(devicePixelRatio)
document.body.appendChild(renderer.domElement)

/* ===== LIGHT ===== */
scene.add(new THREE.AmbientLight(0xffffff,0.8))
const dir = new THREE.DirectionalLight(0xffffff,0.6)
dir.position.set(1,1,1)
scene.add(dir)

/* ===== DATA ===== */
const COUNT = 2800
let targetPoints = []
let shapeType = "square"

const dummy = new THREE.Object3D()

/* ===== MATERIAL ===== */
const material = new THREE.MeshStandardMaterial({
  color:0x5aa9ff,
  roughness:0.35,
  metalness:0.1
})

/* ===== GEOMETRY FACTORY ===== */
function createGeometry(type){
  if(type==="square") return new THREE.BoxGeometry(1.4,1.4,1.4)
  if(type==="sphere") return new THREE.SphereGeometry(0.9,10,10)

  if(type==="star"){
    const s = new THREE.Shape()
    const spikes=5,r1=1,r2=.45
    for(let i=0;i<spikes*2;i++){
      const r=i%2?r2:r1
      const a=i/(spikes*2)*Math.PI*2
      const x=Math.cos(a)*r
      const y=Math.sin(a)*r
      i? s.lineTo(x,y):s.moveTo(x,y)
    }
    s.closePath()
    return new THREE.ExtrudeGeometry(s,{depth:.5,bevelEnabled:false})
  }

  if(type==="heart"){
    const s=new THREE.Shape()
    s.moveTo(0,0)
    s.bezierCurveTo(0,0,-1,-1,-2,0)
    s.bezierCurveTo(-3,2,-1,4,0,3)
    s.bezierCurveTo(1,4,3,2,2,0)
    s.bezierCurveTo(1,-1,0,0,0,0)
    return new THREE.ExtrudeGeometry(s,{depth:.6,bevelEnabled:false})
  }
}

/* ===== INSTANCED MESH ===== */
let mesh = new THREE.InstancedMesh(
  createGeometry(shapeType),
  material,
  COUNT
)
scene.add(mesh)

/* ===== TEXT → POINTS ===== */
function textToPoints(text){
  const len = text.length||1
  const fontSize = Math.max(60,240-len*4)

  const c=document.createElement("canvas")
  c.width=800; c.height=300
  const ctx=c.getContext("2d")
  ctx.clearRect(0,0,800,300)
  ctx.fillStyle="#fff"
  ctx.font=`bold ${fontSize}px Arial`
  ctx.textAlign="center"
  ctx.textBaseline="middle"
  ctx.fillText(text,400,150)

  const img=ctx.getImageData(0,0,800,300).data
  const pts=[]
  for(let y=0;y<300;y+=4){
    for(let x=0;x<800;x+=4){
      const i=(y*800+x)*4
      if(img[i]>200){
        pts.push(new THREE.Vector3(
          (x-400)*0.35,
          (150-y)*0.35,
          0
        ))
      }
    }
  }
  return pts
}

/* ===== UI ===== */
textInput.oninput=e=>{
  const v=e.target.value.trim()
  targetPoints = v?textToPoints(v):[]
}

colorPicker.oninput=e=>material.color.set(e.target.value)

shapeSelect.onchange=e=>{
  shapeType=e.target.value

  if(shapeType==="star"){
    if(confirm("Đổi sang màu vàng cho ngôi sao cho đẹp không?")){
      material.color.set("#FFD54A")
      colorPicker.value="#FFD54A"
    }
  }

  if(shapeType==="heart"){
    if(confirm("Đổi sang màu đỏ cho trái tim cho đẹp không?")){
      material.color.set("#FF4B5C")
      colorPicker.value="#FF4B5C"
    }
  }

  scene.remove(mesh)
  mesh=new THREE.InstancedMesh(
    createGeometry(shapeType),
    material,
    COUNT
  )
  scene.add(mesh)
}

/* ===== LOOP ===== */
function animate(){
  requestAnimationFrame(animate)

  for(let i=0;i<COUNT;i++){
    const p=targetPoints[i%targetPoints.length] || new THREE.Vector3()
    dummy.position.lerp(p,0.12)
    dummy.updateMatrix()
    mesh.setMatrixAt(i,dummy.matrix)
  }
  mesh.instanceMatrix.needsUpdate=true
  mesh.rotation.y+=0.0015

  renderer.render(scene,camera)
}
animate()

window.onresize=()=>{
  camera.aspect=innerWidth/innerHeight
  camera.updateProjectionMatrix()
  renderer.setSize(innerWidth,innerHeight)
}
</script>
</body>
</html>
