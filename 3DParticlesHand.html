<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8" />
<title>Hand Controlled Particles</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
html, body {
  margin: 0;
  overflow: hidden;
  background: #0b0b0e;
  font-family: system-ui;
}

#ui {
  position: fixed;
  top: 16px;
  left: 16px;
  z-index: 10;
  background: rgba(20,20,30,0.6);
  backdrop-filter: blur(10px);
  padding: 12px;
  border-radius: 12px;
  color: white;
}

input[type=color] {
  width: 40px;
  height: 40px;
  border: none;
  background: none;
  cursor: pointer;
}

video { display: none; }
</style>
</head>

<body>
<div id="ui">
  ðŸŽ¨ <input type="color" id="colorPicker" value="#5aa9ff">
</div>
<video id="video" autoplay playsinline></video>

<!-- THREE -->
<script src="https://cdn.jsdelivr.net/npm/three@0.158/build/three.min.js"></script>

<!-- MEDIAPIPE -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
/* ===== THREE ===== */
const scene = new THREE.Scene()
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 1000)
camera.position.z = 120

const renderer = new THREE.WebGLRenderer({ antialias: true })
renderer.setSize(innerWidth, innerHeight)
renderer.setPixelRatio(devicePixelRatio)
document.body.appendChild(renderer.domElement)

/* ===== PARTICLES ===== */
const COUNT = 3000
const geometry = new THREE.BufferGeometry()
const positions = new Float32Array(COUNT * 3)
const sphereBase = []

for (let i = 0; i < COUNT; i++) {
  const r = 30
  const t = Math.random() * Math.PI * 2
  const p = Math.acos(2 * Math.random() - 1)

  const x = r * Math.sin(p) * Math.cos(t)
  const y = r * Math.sin(p) * Math.sin(t)
  const z = r * Math.cos(p)

  positions.set([x, y, z], i * 3)
  sphereBase.push(new THREE.Vector3(x, y, z))
}

geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3))

const material = new THREE.PointsMaterial({ size: 1.6, color: 0x5aa9ff })
const particles = new THREE.Points(geometry, material)
scene.add(particles)

/* ===== COLOR ===== */
colorPicker.oninput = e => material.color.set(e.target.value)

/* ===== HAND ===== */
let handDistance = 1
let fingerCount = 0

function countFingers(lm) {
  const tips = [4,8,12,16,20]
  const pips = [3,6,10,14,18]
  let c = 0
  for (let i = 1; i < tips.length; i++) {
    if (lm[tips[i]].y < lm[pips[i]].y) c++
  }
  if (lm[4].x < lm[3].x) c++
  return c
}

const hands = new Hands({
  locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`
})

hands.setOptions({
  maxNumHands: 2,
  minDetectionConfidence: 0.7,
  minTrackingConfidence: 0.7
})

hands.onResults(r => {
  if (!r.multiHandLandmarks) return

  if (r.multiHandLandmarks.length === 2) {
    const a = r.multiHandLandmarks[0][0]
    const b = r.multiHandLandmarks[1][0]
    const dx = a.x - b.x
    const dy = a.y - b.y
    handDistance = Math.sqrt(dx*dx + dy*dy)
    fingerCount = 0
  }

  if (r.multiHandLandmarks.length === 1) {
    fingerCount = countFingers(r.multiHandLandmarks[0])
  }
})

new Camera(video, {
  onFrame: async () => hands.send({ image: video }),
  width: 640,
  height: 480
}).start()

/* ===== SHAPES ===== */
function numberShape(n) {
  const c = document.createElement('canvas')
  c.width = 200; c.height = 300
  const ctx = c.getContext('2d')

  ctx.fillStyle = '#000'
  ctx.fillRect(0,0,200,300)
  ctx.fillStyle = '#fff'
  ctx.font = 'bold 240px Arial'
  ctx.textAlign = 'center'
  ctx.textBaseline = 'middle'
  ctx.fillText(n, 100, 150)

  const img = ctx.getImageData(0,0,200,300).data
  const pts = []

  for (let y=0;y<300;y+=4) {
    for (let x=0;x<200;x+=4) {
      const i=(y*200+x)*4
      if (img[i]>200)
        pts.push(new THREE.Vector3((x-100)*0.4,(150-y)*0.4,0))
    }
  }
  return pts
}

/* ===== LOOP ===== */
let target = sphereBase

function animate() {
  requestAnimationFrame(animate)

  if (fingerCount >= 1 && fingerCount <= 5)
    target = numberShape(fingerCount)
  else {
    const s = THREE.MathUtils.clamp(handDistance * 4, 0.6, 3)
    target = sphereBase.map(v => v.clone().multiplyScalar(s))
  }

  const pos = geometry.attributes.position.array
  for (let i=0;i<COUNT;i++) {
    const t = target[i % target.length]
    pos[i*3]   += (t.x - pos[i*3]) * 0.1
    pos[i*3+1] += (t.y - pos[i*3+1]) * 0.1
    pos[i*3+2] += (t.z - pos[i*3+2]) * 0.1
  }

  geometry.attributes.position.needsUpdate = true
  particles.rotation.y += 0.002
  renderer.render(scene,camera)
}

animate()
</script>
</body>
</html>
